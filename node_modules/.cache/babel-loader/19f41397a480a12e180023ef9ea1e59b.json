{"ast":null,"code":"/*!\n * Cluster - Worker\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nvar EventEmitter = require('events').EventEmitter,\n    spawn = require('child_process').spawn,\n    binding = process.binding('net'),\n    utils = require('./utils'),\n    net = require('net');\n/**\n * Node binary.\n */\n\n\nvar node = process.execPath;\n/**\n * Initialize a new `Worker` with the given `master`.\n *\n * Signals:\n *\n *   - `SIGINT`   immediately exit\n *   - `SIGTERM`  immediately exit\n *   - `SIGQUIT`  graceful exit\n *\n * @param {Master} master\n * @api private\n */\n\nvar Worker = module.exports = function Worker(master) {\n  this.master = master;\n  this.server = master.server;\n};\n/**\n * Inherit from `EventEmitter.prototype`.\n */\n\n\nWorker.prototype.__proto__ = EventEmitter.prototype;\n/**\n * Worker is a receiver.\n */\n\nrequire('./mixins/receiver')(Worker.prototype);\n/**\n * Start worker.\n *\n * @api private\n */\n\n\nWorker.prototype.start = function () {\n  var self = this,\n      call = this.master.call; // proxy to provide worker id\n\n  this.master.call = function () {\n    var args = utils.toArray(arguments); // Allow calling master methods that\n    // don't take worker as first argument\n\n    if (false !== args[0]) args.unshift(self.id);\n    return call.apply(this, args);\n  }; // stdin\n\n\n  this.stdin = new net.Socket(0, 'unix');\n  this.stdin.setEncoding('ascii');\n  this.stdin.on('data', this.frame.bind(this));\n  this.stdin.resume(); // demote usr/group\n\n  if (this.server && this.server.listenFD) {\n    this.server.on('listening', function () {\n      var group = self.options.group;\n      if (group) process.setgid(group);\n      var user = self.options.user;\n      if (user) process.setuid(user);\n    }); // stdin\n\n    this.stdin.on('fd', this.server.listenFD.bind(this.server));\n  } // signal handlers\n\n\n  process.on('SIGINT', this.destroy.bind(this));\n  process.on('SIGTERM', this.destroy.bind(this));\n  process.on('SIGQUIT', this.close.bind(this)); // conditionally handle uncaughtException\n\n  process.nextTick(function () {\n    if (!process.listeners('uncaughtException').length) {\n      process.on('uncaughtException', function (err) {\n        // stderr for logs\n        console.error(err.stack || err.message); // report exception\n\n        self.master.call('workerException', err); // exit\n\n        process.nextTick(function () {\n          self.destroy();\n        });\n      });\n    }\n  });\n};\n/**\n * Received connect event, set the worker `id`\n * and `options`.\n *\n * @param {String} id\n * @param {Object} options\n * @api private\n */\n\n\nWorker.prototype.connect = function (id, options) {\n  this.options = options; // worker id\n\n  this.id = id; // timeout\n\n  this.timeout = options.timeout; // title\n\n  process.title = options['worker title'].replace('{n}', id); // notify master of connection\n\n  this.master.call('connect');\n};\n/**\n * Immediate shutdown.\n *\n * @api private\n */\n\n\nWorker.prototype.destroy = function () {\n  this.emit('close');\n  process.nextTick(process.exit);\n};\n/**\n * Perform graceful shutdown.\n *\n * @api private\n */\n\n\nWorker.prototype.close = function () {\n  var self = this,\n      server = this.server;\n\n  if (server && server.connections) {\n    // stop accepting\n    server.watcher.stop(); // check pending connections\n\n    setInterval(function () {\n      self.master.call('workerWaiting', server.connections);\n      server.connections || self.destroy();\n    }, 2000); // timeout\n\n    if (this.timeout) {\n      setTimeout(function () {\n        self.master.call('workerTimeout', self.timeout);\n        self.destroy();\n      }, this.timeout);\n    }\n  } else {\n    this.destroy();\n  }\n};\n/**\n * Spawn the worker with the given `id`.\n *\n * @param {Number} id\n * @return {Worker} for chaining\n * @api private\n */\n\n\nWorker.prototype.spawn = function (id) {\n  var fds = binding.socketpair(),\n      customFds = [fds[0]].concat(this.master.customFds),\n      env = {}; // merge env\n\n  for (var key in process.env) {\n    env[key] = process.env[key];\n  }\n\n  this.id = env.CLUSTER_WORKER = id; // spawn worker process\n\n  this.proc = spawn(node, this.master.cmd, {\n    customFds: customFds,\n    env: env\n  }); // unix domain socket for ICP + fd passing\n\n  this.sock = new net.Socket(fds[1], 'unix'); // saving file descriptors for later use\n\n  this.fds = fds;\n  return this;\n};\n/**\n * Invoke worker's `method` (called from Master).\n *\n * @param {String} method\n * @param {...} args\n * @api private\n */\n\n\nWorker.prototype.call = function (method) {\n  this.sock.write(utils.frame({\n    args: utils.toArray(arguments, 1),\n    method: method\n  }), 'ascii');\n};","map":null,"metadata":{},"sourceType":"script"}