{"ast":null,"code":"\"use strict\";\n\nvar isPlainFunction = require(\"type/plain-function/is\"),\n    ensureValue = require(\"type/value/ensure\"),\n    isValue = require(\"type/value/is\"),\n    map = require(\"es5-ext/object/map\"),\n    contains = require(\"es5-ext/string/#/contains\");\n\nvar call = Function.prototype.call,\n    defineProperty = Object.defineProperty,\n    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n    getPrototypeOf = Object.getPrototypeOf,\n    hasOwnProperty = Object.prototype.hasOwnProperty,\n    cacheDesc = {\n  configurable: false,\n  enumerable: false,\n  writable: false,\n  value: null\n},\n    define;\n\ndefine = function (name, options) {\n  var value,\n      dgs,\n      cacheName,\n      desc,\n      writable = false,\n      resolvable,\n      flat;\n  options = Object(ensureValue(options));\n  cacheName = options.cacheName;\n  flat = options.flat;\n  if (!isValue(cacheName)) cacheName = name;\n  delete options.cacheName;\n  value = options.value;\n  resolvable = isPlainFunction(value);\n  delete options.value;\n  dgs = {\n    configurable: Boolean(options.configurable),\n    enumerable: Boolean(options.enumerable)\n  };\n\n  if (name !== cacheName) {\n    dgs.get = function () {\n      if (hasOwnProperty.call(this, cacheName)) return this[cacheName];\n      cacheDesc.value = resolvable ? call.call(value, this, options) : value;\n      cacheDesc.writable = writable;\n      defineProperty(this, cacheName, cacheDesc);\n      cacheDesc.value = null;\n      if (desc) defineProperty(this, name, desc);\n      return this[cacheName];\n    };\n  } else if (!flat) {\n    dgs.get = function self() {\n      var ownDesc;\n\n      if (hasOwnProperty.call(this, name)) {\n        ownDesc = getOwnPropertyDescriptor(this, name); // It happens in Safari, that getter is still called after property\n        // was defined with a value, following workarounds that\n        // While in IE11 it may happen that here ownDesc is undefined (go figure)\n\n        if (ownDesc) {\n          if (ownDesc.hasOwnProperty(\"value\")) return ownDesc.value;\n\n          if (typeof ownDesc.get === \"function\" && ownDesc.get !== self) {\n            return ownDesc.get.call(this);\n          }\n\n          return value;\n        }\n      }\n\n      desc.value = resolvable ? call.call(value, this, options) : value;\n      defineProperty(this, name, desc);\n      desc.value = null;\n      return this[name];\n    };\n  } else {\n    dgs.get = function self() {\n      var base = this,\n          ownDesc;\n\n      if (hasOwnProperty.call(this, name)) {\n        // It happens in Safari, that getter is still called after property\n        // was defined with a value, following workarounds that\n        ownDesc = getOwnPropertyDescriptor(this, name);\n        if (ownDesc.hasOwnProperty(\"value\")) return ownDesc.value;\n\n        if (typeof ownDesc.get === \"function\" && ownDesc.get !== self) {\n          return ownDesc.get.call(this);\n        }\n      }\n\n      while (!hasOwnProperty.call(base, name)) base = getPrototypeOf(base);\n\n      desc.value = resolvable ? call.call(value, base, options) : value;\n      defineProperty(base, name, desc);\n      desc.value = null;\n      return base[name];\n    };\n  }\n\n  dgs.set = function (value) {\n    if (hasOwnProperty.call(this, name)) {\n      throw new TypeError(\"Cannot assign to lazy defined '\" + name + \"' property of \" + this);\n    }\n\n    dgs.get.call(this);\n    this[cacheName] = value;\n  };\n\n  if (options.desc) {\n    desc = {\n      configurable: contains.call(options.desc, \"c\"),\n      enumerable: contains.call(options.desc, \"e\")\n    };\n\n    if (cacheName === name) {\n      desc.writable = contains.call(options.desc, \"w\");\n      desc.value = null;\n    } else {\n      writable = contains.call(options.desc, \"w\");\n      desc.get = dgs.get;\n      desc.set = dgs.set;\n    }\n\n    delete options.desc;\n  } else if (cacheName === name) {\n    desc = {\n      configurable: Boolean(options.configurable),\n      enumerable: Boolean(options.enumerable),\n      writable: Boolean(options.writable),\n      value: null\n    };\n  }\n\n  delete options.configurable;\n  delete options.enumerable;\n  delete options.writable;\n  return dgs;\n};\n\nmodule.exports = function (props) {\n  return map(props, function (desc, name) {\n    return define(name, desc);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}