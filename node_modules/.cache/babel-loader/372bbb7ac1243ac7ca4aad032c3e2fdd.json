{"ast":null,"code":"/*!\n * Cluster - Master\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nvar Worker = require('./worker'),\n    EventEmitter = require('events').EventEmitter,\n    dirname = require('path').dirname,\n    spawn = require('child_process').spawn,\n    utils = require('./utils'),\n    fsBinding = process.binding('fs'),\n    netBinding = process.binding('net'),\n    bind = netBinding.bind,\n    listen = netBinding.listen,\n    socket = netBinding.socket,\n    socketpair = netBinding.socketpair,\n    close = netBinding.close,\n    unlink = fsBinding.unlink,\n    dgram = require('dgram'),\n    tty = require('tty'),\n    net = require('net'),\n    fs = require('fs'),\n    os = require('os');\n/**\n * Node binary.\n */\n\n\nvar node = process.execPath;\n/**\n * Start a new `Master` with the given `server` or filename to\n * a node module exporting a server.\n *\n * Options:\n *\n *   - `workers`  Number of workers to spawn, defaults to the number of CPUs\n *   - 'working directory`  Working directory defaulting to the script's dir\n *   - 'backlog` Connection backlog, defaulting to 128\n *   - 'socket port` Master socket port defaulting to `8989`\n *   - 'timeout` Worker shutdown timeout in milliseconds, defaulting to 60,000\n *   - 'user` User id / name\n *   - 'group` Group id / name\n *   - `title` Master process title, defaults to \"cluster master\"\n *   - `worker title` Worker process title, defaults to \"cluster worker {n}\"\n *\n * Events:\n *\n *   - `start`. When the IPC server is prepped\n *   - `worker`. When a worker is spawned, passing the `worker`\n *   - `listening`. When the server is listening for connections  \n *   - `closing`. When master is shutting down\n *   - `close`. When master has completed shutting down\n *   - `worker killed`. When a worker has died\n *   - `worker exception`. Worker uncaughtException. Receives the worker / exception\n *   - `worker removed`. Worker removed via `spawn(-n)`\n *   - `kill`. When a `signal` is being sent to all workers\n *   - `restarting`. Restart requested by REPL or signal. Receives an object\n *      which can be patched in order to preserve plugin state.\n *   - `restart`. Restart complete, new master established, previous died.\n *      Receives an object with state preserved by the `restarting` event.\n *                \n * Signals:\n *\n *   - `SIGINT`   hard shutdown\n *   - `SIGTERM`  hard shutdown\n *   - `SIGQUIT`  graceful shutdown\n *   - `SIGUSR2`  graceful restart\n *\n * @param {net.Server|String} server\n * @return {Master}\n * @api public\n */\n\nvar Master = module.exports = function Master(server) {\n  var self = this;\n  this.server = server;\n  this.plugins = [];\n  this.children = [];\n  this.state = 'active';\n  this.startup = new Date();\n  this._killed = 0; // grab server root\n\n  this.cmd = process.argv.slice(1);\n  this.dir = dirname(this.cmd[0]); // environment\n\n  this.env = process.env.NODE_ENV || 'development'; // defaults\n\n  this.options = {\n    'backlog': 128,\n    'working directory': this.dir,\n    'socket port': 8989,\n    'socket addr': '127.0.0.1',\n    'timeout': 60000,\n    'restart threshold': 'development' == this.env ? 5000 : 60000,\n    'restart timeout': 'development' == this.env ? 5000 : 60000,\n    'title': 'cluster',\n    'worker title': 'cluster worker'\n  }; // parent master pid\n\n  this.ppid = process.env.CLUSTER_PARENT_PID ? parseInt(process.env.CLUSTER_PARENT_PID, 10) : null; // process is a worker\n\n  this.isWorker = !!process.env.CLUSTER_MASTER_PID; // process is a child (worker or master replacement)\n\n  this.isChild = this.isWorker || !!process.env.CLUSTER_REPLACEMENT_MASTER; // process is master\n\n  this.isMaster = !this.isWorker; // process id\n\n  this.pid = process.pid;\n  if (this.isMaster) process.env.CLUSTER_MASTER_PID = this.pid; // custom worker fds, defaults to std{out,err}\n\n  this.customFds = [1, 2]; // resolve server filename\n\n  if (this.isWorker && 'string' == typeof this.server) {\n    this.server = require(this.resolve(this.server));\n  } // IPC is prepped\n\n\n  this.on('start', function () {\n    process.chdir(self.options['working directory']);\n  }); // spawn our workers\n\n  this.on('listening', function () {\n    self.spawn(self.options.workers);\n    self.listening = true;\n  }); // kill children on master exception\n\n  if (this.isMaster) {\n    process.on('uncaughtException', function (err) {\n      self.kill('SIGKILL');\n      console.error(err.stack || String(err));\n      process.exit(1);\n    });\n  }\n};\n/**\n * Interit from `EventEmitter.prototype`.\n */\n\n\nMaster.prototype.__proto__ = EventEmitter.prototype;\n/**\n * Worker is a receiver.\n */\n\nrequire('./mixins/receiver')(Master.prototype);\n/**\n * Resolve `path` relative to the server file being executed.\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\n\n\nMaster.prototype.resolve = function (path) {\n  return '/' == path[0] ? path : this.dir + '/' + path;\n};\n/**\n * Return `true` when the environment set by `Master#in()`\n * matches __NODE_ENV__.\n *\n * @return {Boolean}\n * @api private\n */\n\n\nMaster.prototype.__defineGetter__('environmentMatches', function () {\n  if (this._env) return this.env == this._env || 'all' == this._env;\n  return true;\n});\n/**\n * Invoke masters's `method` with worker `id`. (called from Worker)\n *\n * @param {Number} id\n * @param {String} method\n * @param {...} args\n * @api private\n */\n\n\nMaster.prototype.call = function (id, method) {\n  this.sock = this.sock || dgram.createSocket('udp4');\n  var msg = new Buffer(utils.frame({\n    args: utils.toArray(arguments, 2),\n    method: method,\n    id: id\n  }));\n  this.sock.send(msg, 0, msg.length, this.options['socket port'], this.options['socket addr']);\n};\n/**\n * Perform setup tasks then invoke `fn()` when present.\n *\n * @param {Function} fn\n * @return {Master} for chaining\n * @api public\n */\n\n\nMaster.prototype.start = function (fn) {\n  var self = this; // deferred title\n\n  process.title = this.options.title; // prevent listen\n\n  if (this.preventDefault) return this; // env match\n\n  if (this.environmentMatches) {\n    // worker process\n    if (this.isWorker) {\n      this.worker = new Worker(this);\n      this.worker.start(); // master process\n    } else if (fn) {\n      fn(); // standalone\n    } else {\n      this.on('start', function () {\n        self.emit('listening');\n      });\n      if (this.isChild) this.acceptFd();\n      this.setupIPC();\n    }\n  }\n\n  return this;\n};\n/**\n * Defer `http.Server#listen()` call.\n *\n * @param {Number|String} port or unix domain socket path\n * @param {String|Function} host or callback\n * @param {Function} callback\n * @return {Master} for chaining\n * @api public\n */\n\n\nMaster.prototype.listen = function (port, host, callback) {\n  var self = this;\n  if (!this.environmentMatches) return this;\n  if ('function' == typeof host) callback = host, host = null;\n  this.port = port;\n  this.host = host;\n  this.callback = callback;\n  return this.start(function () {\n    self.on('start', function () {\n      self.startListening(!self.isChild);\n    });\n\n    if (self.isChild) {\n      self.acceptFd();\n    } else {\n      self.createSocket(function (err, fd) {\n        if (err) throw err;\n        self.fd = fd;\n        self.setupIPC();\n      });\n    }\n  });\n};\n/**\n * Create / return IPC socket.\n *\n * @api private\n */\n\n\nMaster.prototype.IPCSocket = function () {\n  var self = this;\n  if (this._sock) return this._sock;\n  this._sock = dgram.createSocket('udp4');\n\n  this._sock.on('message', function (msg, info) {\n    try {\n      msg = JSON.parse(msg.toString('ascii'));\n      self.invoke(msg.method, msg.args, self.children[msg.id]);\n    } catch (err) {\n      console.error(err.stack || String(err));\n    }\n  });\n\n  return this._sock;\n};\n/**\n * Setup IPC.\n *\n * @api private\n */\n\n\nMaster.prototype.setupIPC = function () {\n  var self = this; // signal handlers\n\n  this.registerSignalHandlers(); // Default worker to the # of cpus\n\n  this.defaultWorkers(); // udp server for IPC\n\n  this.IPCSocket().on('listening', function () {\n    process.nextTick(function () {\n      self.emit('start');\n    });\n  }); // bind\n\n  this.IPCSocket().bind(this.options['socket port'], this.options['socket addr']);\n};\n/**\n * Conditionally perform the following action, if \n * __NODE_ENV__ matches `env`.\n *\n * Examples:\n *\n *      cluster(server)\n *        .in('development').use(cluster.debug())\n *        .in('development').listen(3000)\n *        .in('production').listen(80);\n *     \n * @param {String} env\n * @return {Master} self or stubs\n * @api public\n */\n\n\nMaster.prototype.in = function (env) {\n  this._env = env;\n  return this;\n};\n/**\n * Set option `key` to `val`.\n *\n * @param {String} key\n * @param {Mixed} val\n * @return {Master} for chaining\n * @api public\n */\n\n\nMaster.prototype.set = function (key, val) {\n  if (this.environmentMatches) this.options[key] = val;\n  return this;\n};\n/**\n * Invoke `fn(master)`.\n *\n * @param {Function} fn\n * @api public\n */\n\n\nMaster.prototype.do = function (fn) {\n  if (this.environmentMatches) fn.call(this, this);\n  return this;\n};\n/**\n * Check if `option` has been set.\n *\n * @param {String} option\n * @return {Boolean}\n * @api public\n */\n\n\nMaster.prototype.has = function (option) {\n  return !!this.options[option];\n};\n/**\n * Use the given `plugin`.\n *\n * @param {Function} plugin\n * @return {Master} for chaining\n * @api public\n */\n\n\nMaster.prototype.use = function (plugin) {\n  if (this.environmentMatches) {\n    this.plugins.push(plugin);\n\n    if (this.isWorker) {\n      plugin.enableInWorker && plugin(this);\n    } else {\n      plugin(this);\n    }\n  }\n\n  return this;\n};\n/**\n * Create listening socket and callback `fn(err, fd)`.\n *\n * @return {Function} fn\n * @api private\n */\n\n\nMaster.prototype.createSocket = function (fn) {\n  var self = this,\n      ipv; // explicit host\n\n  if (this.host) {\n    // ip\n    if (ipv = net.isIP(this.host)) {\n      fn(null, socket('tcp' + ipv)); // lookup\n    } else {\n      require('dns').lookup(this.host, function (err, ip, ipv) {\n        if (err) return fn(err);\n        self.host = ip;\n        fn(null, socket('tcp' + ipv));\n      });\n    } // local socket\n\n  } else if ('string' == typeof this.port) {\n    fn(null, socket('unix')); // only port\n  } else if ('number' == typeof this.port) {\n    fn(null, socket('tcp4'));\n  }\n};\n/**\n * Register signal handlers.\n *\n * @api private\n */\n\n\nMaster.prototype.registerSignalHandlers = function () {\n  var self = this;\n  process.on('SIGINT', this.destroy.bind(this));\n  process.on('SIGTERM', this.destroy.bind(this));\n  process.on('SIGQUIT', this.close.bind(this));\n  process.on('SIGUSR2', this.attemptRestart.bind(this));\n  process.on('SIGCHLD', this.maintainWorkerCount.bind(this));\n};\n/**\n * Default workers to the number of cpus available.\n *\n * @api private\n */\n\n\nMaster.prototype.defaultWorkers = function () {\n  if (!this.has('workers')) {\n    this.set('workers', os ? os.cpus().length : 1);\n  }\n};\n/**\n * Restart workers only, sending `signal` defaulting\n * to __SIGQUIT__.\n *\n * @param {Type} name\n * @return {Type}\n * @api public\n */\n\n\nMaster.prototype.restartWorkers = function (signal) {\n  this.kill(signal || 'SIGQUIT');\n};\n/**\n * Maintain worker count, re-spawning if necessary.\n *\n * @api private\n */\n\n\nMaster.prototype.maintainWorkerCount = function () {\n  this.children.forEach(function (worker) {\n    var pid = worker.proc.pid;\n    if (!pid) this.workerKilled(worker);\n  }, this);\n};\n/**\n * Remove `n` workers with `signal`\n * defaulting to __SIGQUIT__.\n *\n * @param {Number} n\n * @param {String} signal\n * @api public\n */\n\n\nMaster.prototype.remove = function (n, signal) {\n  if (!arguments.length) n = 1;\n  var len = this.children.length,\n      worker; // cap at worker len\n\n  if (n > len) n = len; // remove the workers\n\n  while (n--) {\n    worker = this.children.pop();\n    worker.proc.kill(signal || 'SIGQUIT');\n    this.emit('worker removed', worker);\n    this.removeWorker(worker.id);\n  }\n};\n/**\n * Remove worker `id`.\n *\n * @param {Number} id\n * @api public\n */\n\n\nMaster.prototype.removeWorker = function (id) {\n  var worker = this.children[id];\n  if (!worker) return;\n\n  if (worker.fds) {\n    close(worker.fds[0]);\n    close(worker.fds[1]);\n  }\n\n  delete this.children[id];\n};\n/**\n * Spawn `n` workers.\n *\n * @param {Number} n\n * @api public\n */\n\n\nMaster.prototype.spawn = function (n) {\n  if (!arguments.length) n = 1;\n\n  while (n--) this.spawnWorker();\n};\n/**\n * Spawn a worker with optional `id`.\n *\n * @param {Number} id\n * @return {Worker}\n * @api private\n */\n\n\nMaster.prototype.spawnWorker = function (id) {\n  var worker; // id given\n\n  if ('number' == typeof id) {\n    worker = new Worker(this).spawn(id);\n    this.children[id] = worker;\n    worker.id = id; // generate an id\n  } else {\n    worker = new Worker(this).spawn(this.children.length);\n    this.children.push(worker);\n  }\n\n  var obj = {\n    method: 'connect',\n    args: [worker.id, this.options]\n  };\n  worker.sock.write(utils.frame(obj), 'ascii', this.fd); // emit\n\n  this.emit('worker', worker);\n  return worker;\n};\n/**\n * Graceful shutdown, wait for all workers\n * to reply before exiting.\n *\n * @api public\n */\n\n\nMaster.prototype.close = function () {\n  this.state = 'graceful shutdown';\n  this.emit('closing');\n  this.kill('SIGQUIT');\n  this.pendingDeaths = this.children.length;\n};\n/**\n * Hard shutdwn, immediately kill all workers.\n *\n * @api public\n */\n\n\nMaster.prototype.destroy = function () {\n  this.state = 'hard shutdown';\n  this.emit('closing');\n  this.kill('SIGKILL');\n\n  this._destroy();\n};\n/**\n * Attempt restart, while respecting the `restart threshold`\n * setting, to help prevent recursive restarts.\n *\n * @param {String} sig\n * @api private\n */\n\n\nMaster.prototype.attemptRestart = function (sig) {\n  var uptime = new Date() - this.startup,\n      threshold = this.options['restart threshold'],\n      timeout = this.options['restart timeout'];\n  if (this.__restarting) return;\n\n  if (uptime < threshold) {\n    this.__restarting = true;\n    this.emit('cyclic restart');\n    setTimeout(function (self) {\n      self.restart(sig);\n    }, timeout, this);\n  } else {\n    this.restart(sig);\n  }\n};\n/**\n * Restart all workers, by sending __SIGQUIT__\n * or `sig` to them, enabling master to re-spawn.\n *\n * @param {String} sig\n * @return {ChildProcess} replacement master process\n * @api public\n */\n\n\nMaster.prototype.restart = function (sig) {\n  var data = {},\n      proc = this.spawnMaster(); // pass object to plugins, allowing them\n  // to patch it, and utilize the data in\n  // the new Master\n\n  this.emit('restarting', data);\n  proc.sock.write(utils.frame({\n    method: 'connectMaster',\n    args: [sig || 'SIGQUIT']\n  }), 'ascii', this.fd);\n  this.on('close', function () {\n    proc.sock.write(utils.frame({\n      method: 'masterKilled',\n      args: [data]\n    }), 'ascii');\n  });\n  return proc;\n};\n/**\n * Spawn a new master process.\n *\n * @return {ChildProcess}\n * @api private\n */\n\n\nMaster.prototype.spawnMaster = function () {\n  var fds = socketpair(),\n      customFds = [fds[0], 1, 2],\n      env = {}; // merge current env\n\n  for (var key in process.env) {\n    env[key] = process.env[key];\n  }\n\n  delete env.CLUSTER_MASTER_PID;\n  env.CLUSTER_REPLACEMENT_MASTER = 1;\n  env.CLUSTER_PARENT_PID = this.pid; // spawn new master process\n\n  var proc = spawn(node, this.cmd, {\n    customFds: customFds,\n    env: env\n  }); // unix domain socket for ICP + fd passing\n\n  proc.sock = new net.Socket(fds[1], 'unix');\n  return proc;\n};\n/**\n * Master replacement connected.\n *\n * @param {String} sig\n * @api private\n */\n\n\nMaster.prototype.connectMaster = function (sig) {\n  var self = this;\n\n  function kill() {\n    process.kill(self.ppid, sig);\n  }\n\n  if (this.listening) return kill();\n  this.on('listening', kill);\n};\n/**\n * Original master has died aka 'retired',\n * we now fire the 'restart' event.\n *\n * @param {Object} data\n * @api private\n */\n\n\nMaster.prototype.masterKilled = function (data) {\n  this.emit('restart', data);\n};\n/**\n * Accept fd from parent master, then `setupIPC()`.\n *\n * @api private\n */\n\n\nMaster.prototype.acceptFd = function () {\n  var self = this,\n      stdin = new net.Socket(0, 'unix'); // set fd and start master\n\n  stdin.setEncoding('ascii');\n  stdin.on('fd', function (fd) {\n    self.fd = fd;\n    self.setupIPC();\n  }); // frame commands from the parent master\n\n  stdin.on('data', this.frame.bind(this));\n  stdin.resume();\n};\n/**\n * Close servers and emit 'close' before exiting.\n *\n * @api private\n */\n\n\nMaster.prototype._destroy = function () {\n  this.IPCSocket().close();\n  if (this.fd) close(this.fd);\n  this.emit('close');\n  process.nextTick(process.exit.bind(process));\n};\n/**\n * Worker is connected.\n *\n * @param {Worker} worker\n * @api private\n */\n\n\nMaster.prototype.connect = function (worker) {\n  this.emit('worker connected', worker);\n};\n/**\n * Start listening, when `shouldBind` is `true` the socket\n * will be bound, and will start listening for connections.\n *\n * @param {Boolean} shouldBind\n * @api private\n */\n\n\nMaster.prototype.startListening = function (shouldBind) {\n  var self = this; // remove unix domain socket \n\n  if ('string' == typeof this.port && shouldBind) {\n    fs.unlink(this.port, function (err) {\n      if (err && 'ENOENT' != err.code) throw err;\n      startListening();\n    });\n  } else {\n    startListening();\n  } // bind / listen\n\n\n  function startListening() {\n    if (shouldBind) {\n      try {\n        bind(self.fd, self.port, self.host);\n        listen(self.fd, self.options.backlog);\n      } catch (e) {\n        self.kill('SIGKILL');\n        throw e;\n      }\n    }\n\n    self.callback && self.callback();\n    self.emit('listening');\n  }\n};\n/**\n * The given `worker` has been killed.\n * Emit the \"worker killed\" event, remove\n * the worker, and re-spawn depending on \n * the master state.\n *\n * @api private\n */\n\n\nMaster.prototype.workerKilled = function (worker) {\n  // if we have many failing workers at boot\n  // then we likely have a serious issue.\n  if (new Date() - this.startup < 20000) {\n    if (++this._killed == 20) {\n      console.error('');\n      console.error('Cluster detected over 20 worker deaths in the first');\n      console.error('20 seconds of life, there is most likely');\n      console.error('a serious issue with your server.');\n      console.error('');\n      console.error('aborting.');\n      console.error('');\n      process.exit(1);\n    }\n  } // emit event\n\n\n  this.emit('worker killed', worker); // always remove worker\n\n  this.removeWorker(worker.id); // state specifics\n\n  switch (this.state) {\n    case 'hard shutdown':\n      break;\n\n    case 'graceful shutdown':\n      --this.pendingDeaths || this._destroy();\n      break;\n\n    default:\n      this.spawnWorker(worker.id);\n  }\n};\n/**\n * `worker` received exception `err`.\n *\n * @api private\n */\n\n\nMaster.prototype.workerException = function (worker, err) {\n  this.emit('worker exception', worker, err);\n};\n/**\n * Received worker timeout.\n * \n * @api private\n */\n\n\nMaster.prototype.workerTimeout = function (worker, timeout) {\n  this.emit('worker timeout', worker, timeout);\n};\n/**\n * Worker waiting on `connections` to close.\n * \n * @api private\n */\n\n\nMaster.prototype.workerWaiting = function (worker, connections) {\n  this.emit('worker waiting', worker, connections);\n};\n/**\n * Send `sig` to all worker processes, defaults to __SIGTERM__.\n *\n * @param {String} sig\n * @api public\n */\n\n\nMaster.prototype.kill = function (sig) {\n  var self = this;\n  this.emit('kill', sig);\n  this.children.forEach(function (worker) {\n    worker.proc.kill(sig);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}